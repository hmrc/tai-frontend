/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.tai.service.benefits

import cats.data.EitherT
import org.mockito.ArgumentMatchers.{any, eq => meq}
import org.scalatest.concurrent.ScalaFutures
import play.api.http.Status._
import play.api.libs.json.{JsObject, Json}
import uk.gov.hmrc.http.{HttpResponse, UpstreamErrorResponse}
import uk.gov.hmrc.tai.connectors.BenefitsConnector
import uk.gov.hmrc.tai.model.domain.benefits._
import utils.BaseSpec

import scala.concurrent.Future
import scala.language.postfixOps

class BenefitsServiceSpec extends BaseSpec {

  private val mockBenefitsConnector = mock[BenefitsConnector]
  private val service = new BenefitsService(mockBenefitsConnector)

  private val benefits = Benefits(
    Seq(CompanyCarBenefit(1, BigDecimal(10), Seq.empty[CompanyCar], None)),
    Seq.empty[GenericBenefit]
  )

  override def beforeEach(): Unit = {
    super.beforeEach()
    reset(mockBenefitsConnector)
  }

  "BenefitsService" when {
    "benefits" must {
      val taxYear = 2018
      "return benefits if valid data is retrieved from the connector" in {
        when(mockBenefitsConnector.benefits(any(), any())(any()))
          .thenReturn(
            EitherT[Future, UpstreamErrorResponse, HttpResponse](
              Future.successful(Right(HttpResponse(OK, Json.toJson(benefits).toString)))
            )
          )

        val result = service
          .benefits(nino, taxYear)
          .value
          .futureValue
          .getOrElse(Benefits(Seq.empty[CompanyCarBenefit], Seq.empty[GenericBenefit]))
        result mustBe benefits
      }

      "throw an exception if invalid data is retrieved from the connector" in {
        val otherBenefitsJson: JsObject = Json.obj(
          "benefitType"  -> "MedicalInsurance",
          "employmentId" -> 10,
          "amount"       -> 1000
        )
        val invalidOtherBenefitsJson: JsObject = Json.obj(
          "benefitType"  -> "GiftAidPayments",
          "employmentId" -> 10,
          "amount"       -> 1000
        )
        val invalidBenefitsJson: JsObject =
          Json.obj(
            "data" -> Json.obj(
              "companyCarBenefits" -> Json.arr(invalidOtherBenefitsJson),
              "otherBenefits"      -> Json.arr(otherBenefitsJson)
            ),
            "links" -> Json.arr()
          )

        when(mockBenefitsConnector.benefits(any(), any())(any()))
          .thenReturn(
            EitherT[Future, UpstreamErrorResponse, HttpResponse](
              Future.successful(Right(HttpResponse(OK, Json.toJson(invalidBenefitsJson).toString)))
            )
          )

        assertThrows[RuntimeException](service.benefits(nino, taxYear).value.futureValue)
      }

      List(
        NOT_FOUND,
        BAD_REQUEST,
        IM_A_TEAPOT,
        INTERNAL_SERVER_ERROR,
        BAD_GATEWAY,
        SERVICE_UNAVAILABLE
      ).foreach { errorStatus =>
        s"return the UpstreamErrorException generated by the connector containing $errorStatus" in {
          when(mockBenefitsConnector.benefits(any(), any())(any()))
            .thenReturn(
              EitherT[Future, UpstreamErrorResponse, HttpResponse](
                Future.successful(Left(UpstreamErrorResponse("", errorStatus)))
              )
            )

          service.benefits(nino, taxYear).value.futureValue.swap.map { result =>
            result mustBe UpstreamErrorResponse("", errorStatus)
          }
        }
      }
    }

    "endedCompanyBenefit" must {
      "return an envelope id" in {
        val endedCompanyBenefit =
          EndedCompanyBenefit("Accommodation", "Before 6th April", Some("1000000"), "Yes", Some("0123456789"))
        val dataValue = "123-456-789"
        val data = Json.obj("data" -> dataValue)
        when(mockBenefitsConnector.endedCompanyBenefit(meq(nino), meq(1), meq(endedCompanyBenefit))(any()))
          .thenReturn(
            EitherT[Future, UpstreamErrorResponse, HttpResponse](
              Future.successful(Right(HttpResponse(OK, data.toString)))
            )
          )

        service
          .endedCompanyBenefit(nino, 1, endedCompanyBenefit)
          .value
          .futureValue
          .map(result => result mustBe dataValue)
      }

      "return a Left if the response contains no data to generate an envelope id" in {
        val endedCompanyBenefit =
          EndedCompanyBenefit("Accommodation", "Before 6th April", Some("1000000"), "Yes", Some("0123456789"))
        when(mockBenefitsConnector.endedCompanyBenefit(meq(nino), meq(1), meq(endedCompanyBenefit))(any()))
          .thenReturn(
            EitherT[Future, UpstreamErrorResponse, HttpResponse](
              Future.successful(Right(HttpResponse(OK, Json.obj("d" -> "").toString)))
            )
          )

        val result =
          service
            .endedCompanyBenefit(nino, 1, endedCompanyBenefit)
            .value
            .futureValue
        result mustBe a[Left[_, _]]
      }

      List(
        NOT_FOUND,
        BAD_REQUEST,
        IM_A_TEAPOT,
        INTERNAL_SERVER_ERROR,
        BAD_GATEWAY,
        SERVICE_UNAVAILABLE
      ).foreach { errorStatus =>
        s"return the UpstreamErrorException generated by the connector containing $errorStatus" in {
          val endedCompanyBenefit =
            EndedCompanyBenefit("Accommodation", "Before 6th April", Some("1000000"), "Yes", Some("0123456789"))
          when(mockBenefitsConnector.endedCompanyBenefit(meq(nino), meq(1), meq(endedCompanyBenefit))(any()))
            .thenReturn(
              EitherT[Future, UpstreamErrorResponse, HttpResponse](
                Future.successful(Left(UpstreamErrorResponse("", errorStatus)))
              )
            )

          service
            .endedCompanyBenefit(nino, 1, endedCompanyBenefit)
            .value
            .futureValue
            .swap
            .map(result => result.statusCode mustBe errorStatus)
        }
      }
    }
  }
}
