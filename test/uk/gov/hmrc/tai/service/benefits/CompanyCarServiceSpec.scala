/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.tai.service.benefits

import cats.data.EitherT

import java.time.LocalDate
import org.mockito.ArgumentMatchers.any
import org.mockito.Mockito
import org.scalatest.BeforeAndAfterEach
import play.api.http.Status._
import play.api.libs.json.Json
import uk.gov.hmrc.domain.{Generator, Nino}
import uk.gov.hmrc.http.{HttpResponse, UpstreamErrorResponse}
import uk.gov.hmrc.tai.connectors.CompanyCarConnector
import uk.gov.hmrc.tai.model.domain._
import uk.gov.hmrc.tai.model.domain.benefits.{CompanyCar, CompanyCarBenefit}
import uk.gov.hmrc.tai.model.domain.calculation.CodingComponent
import uk.gov.hmrc.tai.model.domain.income.Live
import utils.BaseSpec

import scala.concurrent.duration._
import scala.concurrent.{Await, Future}
import scala.language.postfixOps
import scala.util.Random

class CompanyCarServiceSpec extends BaseSpec with BeforeAndAfterEach {

  lazy val connector: CompanyCarConnector = mock[CompanyCarConnector]

  lazy val service: CompanyCarService = new CompanyCarService(connector)

  override def beforeEach: Unit =
    Mockito.reset(connector)

  "CompanyCarService" when {
    val companyCar = CompanyCarBenefit(
      10,
      1000,
      List(
        CompanyCar(
          10,
          "Make Model",
          hasActiveFuelBenefit = true,
          dateMadeAvailable = Some(LocalDate.parse("2016-10-10")),
          dateActiveFuelBenefitMadeAvailable = Some(LocalDate.parse("2016-10-11")),
          dateWithdrawn = None
        )
      ),
      Some(1)
    )
    val companyCarWithDateWithDrawn = CompanyCarBenefit(
      10,
      1000,
      List(
        CompanyCar(
          10,
          "Make Model",
          hasActiveFuelBenefit = false,
          dateMadeAvailable = Some(LocalDate.parse("2016-10-10")),
          dateActiveFuelBenefitMadeAvailable = Some(LocalDate.parse("2016-10-11")),
          dateWithdrawn = Some(LocalDate.parse("2017-05-12"))
        )
      ),
      Some(1)
    )
    val companyCars = Seq(companyCar, companyCarWithDateWithDrawn)

    "companyCars is run" must {
      "return a sequence of CompanyCarBenefit when the connector returns an OK status with valid data" in {
        when(connector.companyCarsForCurrentYearEmployments(any())(any(), any()))
          .thenReturn(
            EitherT[Future, UpstreamErrorResponse, HttpResponse](
              Future.successful(Right(HttpResponse(OK, Json.toJson(companyCars).toString)))
            )
          )

        service.companyCars(nino).value.futureValue.map { result =>
          result mustBe companyCars
        }
      }
      "return an empty sequence when the connector returns an OK status with no data" in {
        when(connector.companyCarsForCurrentYearEmployments(any())(any(), any()))
          .thenReturn(
            EitherT[Future, UpstreamErrorResponse, HttpResponse](
              Future.successful(Right(HttpResponse(OK, Json.toJson(Seq.empty[CompanyCarBenefit]).toString)))
            )
          )

        service.companyCars(nino).value.futureValue.map { result =>
          result mustBe Seq.empty[CompanyCarBenefit]
        }
      }

      List(
        NOT_FOUND,
        BAD_REQUEST,
        IM_A_TEAPOT,
        INTERNAL_SERVER_ERROR,
        BAD_GATEWAY,
        SERVICE_UNAVAILABLE
      ).foreach { errorStatus =>
        s"return the UpstreamErrorException generated by the connector containing $errorStatus" in {

          when(connector.companyCarsForCurrentYearEmployments(any())(any(), any()))
            .thenReturn(
              EitherT[Future, UpstreamErrorResponse, HttpResponse](
                Future.successful(Left(UpstreamErrorResponse("", errorStatus)))
              )
            )

          service.companyCars(nino).value.futureValue.swap.map { result =>
            result.statusCode mustBe errorStatus
          }
        }
      }
    }

    "return empty seq of company car benefits" must { // TODO Method may be pointless, check after refactoring
      "connector returns empty seq" in {
        val codingComponents = Seq(
          CodingComponent(GiftAidPayments, None, 1000, "GiftAidPayments description"),
          CodingComponent(GiftAidPayments, None, 1000, "GiftAidPayments description"),
          CodingComponent(CarBenefit, None, 1000, "CarBenefit description")
        )
        when(connector.companyCarsForCurrentYearEmployments(any())(any(), any()))
          .thenReturn(
            EitherT[Future, UpstreamErrorResponse, HttpResponse](
              Future.successful(Right(HttpResponse(OK, Json.toJson(Seq.empty[CompanyCarBenefit]).toString)))
            )
          )

        val result = service.companyCarOnCodingComponents(generateNino, codingComponents)
        Await.result(result, 5 seconds) mustBe Seq.empty[CompanyCarBenefit]
        verify(connector, times(1)).companyCarsForCurrentYearEmployments(any())(any(), any())
      }

      "Coding components don't have company car benefit" in { // TODO Method may be pointless, check after refactoring
        val codingComponents = Seq(
          CodingComponent(GiftAidPayments, None, 1000, "GiftAidPayments description"),
          CodingComponent(GiftAidPayments, None, 1000, "GiftAidPayments description")
        )

        val result = service.companyCarOnCodingComponents(generateNino, codingComponents)
        Await.result(result, 5 seconds) mustBe Seq.empty[CompanyCarBenefit]
        verify(connector, times(0)).companyCarsForCurrentYearEmployments(any())(any(), any())
      }
    }

//    "return seq of company car by removing withdrawn company cars" must { // TODO Method may be pointless, check after refactoring
//      "Coding components have company car benefit" in {
//        val codingComponents = Seq(
//          CodingComponent(GiftAidPayments, None, 1000, "GiftAidPayments description"),
//          CodingComponent(GiftAidPayments, None, 1000, "GiftAidPayments description"),
//          CodingComponent(CarBenefit, None, 1000, "CarBenefit description")
//        )
//        when(connector.companyCarsForCurrentYearEmployments(any())(any()))
//          .thenReturn(
//            EitherT[Future, UpstreamErrorResponse, HttpResponse](
//              Future.successful(Right(HttpResponse(OK, Json.toJson(companyCars).toString)))
//            )
//          )
//
//        val result = service.companyCarOnCodingComponents(generateNino, codingComponents)
//        Await.result(result, 5 seconds) mustBe Seq(companyCar)
//      }
//    }
  }

  val companyCarListWithDateWithDrawn = CompanyCarBenefit(
    10,
    1000,
    List(
      CompanyCar(
        10,
        "Make Model",
        hasActiveFuelBenefit = false,
        dateMadeAvailable = Some(LocalDate.parse("2016-10-10")),
        dateActiveFuelBenefitMadeAvailable = Some(LocalDate.parse("2016-10-11")),
        dateWithdrawn = Some(LocalDate.parse("2017-05-12"))
      ),
      CompanyCar(
        11,
        "Make Model2",
        hasActiveFuelBenefit = true,
        dateMadeAvailable = Some(LocalDate.parse("2016-10-10")),
        dateActiveFuelBenefitMadeAvailable = Some(LocalDate.parse("2016-10-11")),
        dateWithdrawn = None
      )
    ),
    Some(1)
  )

  val companyCarMissingStartDates = CompanyCarBenefit(
    10,
    1000,
    List(
      CompanyCar(
        10,
        "Make Model",
        hasActiveFuelBenefit = true,
        dateMadeAvailable = None,
        dateActiveFuelBenefitMadeAvailable = None,
        dateWithdrawn = None
      )
    ),
    Some(1)
  )

  val employment =
    Employment("The Man Plc", Live, None, LocalDate.parse("2016-06-09"), None, Nil, "", "", 1, None, false, false)

  def generateNino: Nino = new Generator(new Random).nextNino
}
